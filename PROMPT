now, let's create a new category of tests - a sub-class of the 'check_'
category, which checks for partial goals. for example, if we check:

def assoc(a: Nat, b: Nat, c: Nat) -> Nat{add(add(a,b), c) == add(a, add(b,c))}:
  match a:
    case 0n:
      ()
    case 1n + ap:
      1n + assoc(ap, b, c)

we get:

Mismatch:
- Goal: Nat{add(b,c)==add(b,c)}
- Type: Unit
Context:
- b : Nat
- c : Nat

i.e., the goal is correctly reduced to b+c == b+c on the zero case.

similarly, if we check:

# Add: associativity (helper)
def assoc(a: Nat, b: Nat, c: Nat) -> Nat{add(add(a,b), c) == add(a, add(b,c))}:
  match a:
    case 0n:
      {==}
    case 1n + ap:
      ()

we get:

Mismatch:
- Goal: Nat{1n+add(add(ap,b),c)==1n+add(ap,add(b,c))}
- Type: Unit
Context:
- ap : Nat
- b : Nat
- c : Nat

and if we check:

def assoc(a: Nat, b: Nat, c: Nat) -> Nat{add(add(a,b), c) == add(a, add(b,c))}:
  match a:
    case 0n:
      {==}
    case 1n + ap:
      1n + ()

we get:

Mismatch:
- Goal: Nat{add(add(ap,b),c)==add(ap,add(b,c))}
- Type: Unit
Context:
- ap : Nat
- b : Nat
- c : Nat

which are all correctly specialized.

we will call this new category check_..._goal_N, where N is a number starting
from 0. so, for example, the tests above could be named:

check_add_associative_goal_0.hs
check_add_associative_goal_1.hs
check_add_associative_goal_2.hs

and they would check if the goal shown by Bend matches the expected goal.

create a 'testFileGoal' util for that.

example: 'testFileGoal add_associative_bend "Nat{add(b,c)==add(b,c)}" []'

the last argument is a '(String,String)' list, which allows us to also test
the type of variables in the shown context. example:

["e","Nat{0n==x}"]

would check that the context includes "- e : Nat{0n==x}".

then, for each *proof* in the tests dir, split it into additional files, placing
holes in different stages of the proof, and checking if the goal reported by
Bend correponds to what we expect.
